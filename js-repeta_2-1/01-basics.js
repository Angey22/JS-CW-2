/*
 * Знакомство  с массивами:
 * - объявление массива;
 * - индексация элементов массива;
 * - "длина" массива;
 * - индекс последнего элемента массива;
 * - переопределение - перезапись элемента массива.
 */
// Массив - это некий список, который зачастую предназначен для хранения "коллекции" одотипных данных.
// Для создания массива нужно задать основу его литерала - "[]".
// Элементы массива разделяются в теле массива с помощью запятой - ['Mango', 'Kiwi', 'Poly', 'Ajax'] (это массив состоящий из 4-х строчных элементов).

const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];
console.log(friends); // => (4) ['Mango', 'Kiwi', 'Poly', 'Ajax']
// Отображение массива в консоли через "console.log([массив])" имеет свои особенности:
// 1) В начале отображается круглая скобка с числовым индикатором внутри, который указывает на количество элементов находящихся в масиве, например - "(4)" - указавает, что масив состоит из 4-х элементов;
// 2) Далее отображается квадратные скобки внутри которых визуализируется перечень составляющих элементов массива, разделенных между собой с помощью символа ",", например - "['Mango', 'Kiwi', 'Poly', 'Ajax']" - отображает массив из 4-х строчных элементов внутри;
// 3) В начале строки с отображенным в консоли массивом есть стрелочка, нажав на которую можно "развернуть" массив в "вертикально" отображаемый вид (смотри пример в консоли), и наути внизу соответствующего перечня 2-а дополнительных пункта с характеристиками массива: "length" - числоввой характеристикой его "длины" (количества элементов в нем) и "[[Prototype]]" - дополнительно разварачиваемого пункта с перечнем всех методов, которые можно применить по отношению к массиву.


// Для автоматического вывода целочисленного значения "длины" массива, можно использовать метод "length"
console.log('Целочисленная "длина" массива "friends" =', friends.length);


// Более удобный способ вывода "логирования" массива в консоль, основан на использовании команды - "console.table([массив])". Которая активирует отображение массива в виде таблицы, в которой отображаются минимум две колонки "(index)" - индекс элемента массива, и "Value" - значение или содержание элемента массива. Если у элементов массива заданы-активированы дополнительные характиристики, то колонок в таблице будет больше, в соответствии с количеством заданных характеристик элементов масива.
console.log('Вывод массива в "лог", с помощью команды "console.table([массив])":');
console.table(friends);


// Индекс элемента массива - это натуральное число, а индекс 1-го элемента в массиве всегда - "0", второго, соответственно - "1", третего - "2" и т.д.
// Для определения индекса последнего элемента массива, так же как и для определения индекса последнего символа в строке (строка - это тоже массив, элементами которого являются символы), можно использовать конструкцию на основе команды - "length - 1"
console.log('Определяем индекс последнего элемента массива "friends":', friends.length - 1);


// Важной особенностью массива является то, что он представляет собой сложный тип данный, который называется - "объектом". В следствии чего, возникает возможность производить любые изменения с данными находящимися внутри массива - "без необходимости его переопределять (перезаписывать и/или переназначать) как переменную любого другого типа данных". При работе с масивом, достаточно один раз его "объявить" в какой-то НЕИЗМЕНЯЕМОЙ (const) переменной, и потом обращаться (добавлять, удалять, копировать и т.д.) к находящимся внутри него данным. По сути, массив - это своеобарзный набор "ячеек" памяти, внутри которых находятся данные, с которыми и производится взаимодействие не затрагивая "внешнюю конструкцию" самого массива.
// Для обращения к элементу, который находится внутри массива необходимо использовать следующую конструкцию - "имя переменной-массива[индекс элемента]".
console.log('Обращаемся к элементу массива "freinds" - с индексом "0" =>', friends[0]);
console.log('Обращаемся к элементу массива "freinds" - с индексом "2" =>', friends[2]);

// Еще один способ обращения к элементу массива, основан на использовании полной записи его литерала и индекса нужного єлемента в двух расположенных друг за другом квадратных скобках - "[22, 33, 44][2]"
console.log('Обращаемся к элементу массива "[22, 33, 44][2]" через литерал =>', [22, 33, 44][2]);

// Если при обращении к элементу массива использовать индекс "НЕ существующего" элемента массива - команда вернет "служебную запись - тип данных" -> "undefind"
console.log('Обращаемся к элементу массива, используя НЕ существующий индекс "friends[5]" =>', friends[5]);


// Переопределение или перезапись значений элементов массива выполняется с помощью использования индекса соответствующего элемента массива, значение которого нужно перезаписать.
// Например, у нас есть массив "collegs -> ['Вася', 'Иштван', 'Моня']", и имя 'Вася' нужно заменить на 'Изя':
const collegs = ['Вася', 'Иштван', 'Моня']; // Объявляем переменную - массив
console.log('Массив "collegs" до изменения:', collegs);
collegs[0] = 'Изя'; // Переопределяем значение ячейки массива под индексом "0"
console.log('Массив "collegs" после 1-го изменения:', collegs);
// Если нужно выполнить еще одну или бесконечное количество подобных переопределений - изменений, они выполняются подобным же образом. Например, в уже измененном один раз массиве "collegs -> ['Изя', 'Иштван', 'Моня']", и имя 'Иштван' нужно заменить на 'Абрам':
collegs[1] = 'Абрам'; // Переопределяем значение ячейки массива под индексом "1"
console.log('Массив "collegs" после 2-го изменения:', collegs);


/*
 * Передача по ссылке и по значению:
 * - примитивы и сложные типы;
 * - ссылочное равенство (referential equality).
 */
// Передача данных по значению основана на записи каждого значения в отдельно взятую ячейку памяти. Например, у нас есть некая переменная "а = 10" и некая переменная "b = a". При передачи данных переменной "b" по значению - для записи данных этой переменной (b) - была выделенна отдельная ячейка памяти, в которую записалось значение "10", соответствующее данным введенным в переменную "b" при ее объявлении. После чего, даже если значение переменной "а" изменится на любое другое, переменная "b" - всеравно будет хранить в себе уже записанное в отдельную ячейку памяти значение "10".

let a = 10; // Объявляем переменную "а" и задаем ей значение "10"
let b = a; // Объявляем переменную "b" и задаем ей значение "= переменной а"
console.log('Начальное значение переменной "а":', a);
console.log('Начальное значение переменной "b":', b);

a = 33; // Изменяем данные в переменной "а"
console.log('Значение переменной "а", после его изменения:', a);
console.log('Значение переменной "b", после изменения переменной "а":', b);


// Передача данных по ссылке работает иначе чем передача данных по значению. Дело в том, что для сложных типов данных, таких как массивы, объекты и функции - любые переменные являются только своеобразными ссылками на место в памяти (на ячейку в памяти), где хранится тот или иной сложный тип данных. Всвязи с чем, на один и тот-же сложный объект, может указывать несколько или целая группа переменных, и при этом, изменения в данных самого такого массива, могут быть осуществленны через любую из переменных связаных сним, а введенные таким образом изменения через одну переменную - отразятся на значениях всех остальных переменных связаных с соответствующим массивом или другим сложным типом данных.
// Например,  у нас есть некая переменная "x", которой мы задаем значение в виде масива -> "[1, 2, 3]". После чего, объявляем переменную "y" и задаем ей значение "= х". Данной опирацией мы создали две "ссылки" на отдельно хранящийся от переменных массив "[1, 2, 3]", 1-ю ссылку в виде переменной "x", и вторую - "y". Теперь, при изменении значений в данных соответствующего массива через переменную "x", эти же изменения отразятся и на значении переменной "y".

const x = [1, 2, 3]; // Объявляем переменную "x" и задаем ей значение в виде массива
const y = x; // Объявляем переменную "y" и задаем ей значение "= переменной x", т.е. - связываем переменную "y" с тем же самым массивом, с которым уже связана переменная "x"

console.log('Начальное значение переменной "x" =>', x);
console.log('Начальное значение переменной "y" =>', y);

x[1] = 500; // Изменяем данные в одном элементе соответствующего масива, через переменную "x" - используя индекс соответствующего элемента массива

console.log('Значение переменной "x", после изменения =>', x);
console.log('Значение переменной "y", после изменения =>', y);


// console.log(a === b);

// console.log([1, 2, 3] === [1, 2, 3]);

/*
 * Перебор (итерация) массива
 * - for - если нужен индекс или нужно изменить элемент массива
 * - for...of - если индекс не нужен и в массиве ничего менять не нужно
 */

// const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];
// // console.table(friends);
// // const lastIndex = friends.length - 1;

// for (let i = 0; i < friends.length; i += 1) {
//   friends[i] += `-${i}`;
// }

// for (let friend of friends) {
//   console.log(friend);
// }

// console.table(friends);