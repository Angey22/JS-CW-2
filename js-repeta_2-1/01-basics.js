// ! Видео - 0:09:55...0:45:00

/*
 * Знакомство  с массивами:
 * - объявление массива;
 * - индексация элементов массива;
 * - "длина" массива;
 * - индекс последнего элемента массива;
 * - переопределение - перезапись элемента массива.
 */
console.groupCollapsed('Знакомство  с массивами'); //! Log group name

// Массив - это некий список, который зачастую предназначен для хранения "коллекции" одотипных данных.
// Для создания массива нужно задать основу его литерала - "[]".
// Элементы массива разделяются в теле массива с помощью запятой - ['Mango', 'Kiwi', 'Poly', 'Ajax'] (это массив состоящий из 4-х строчных элементов).

const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];
console.log(friends); // => (4) ['Mango', 'Kiwi', 'Poly', 'Ajax']
// Отображение массива в консоли через "console.log([массив])" имеет свои особенности:
// 1) В начале отображается круглая скобка с числовым индикатором внутри, который указывает на количество элементов находящихся в масиве, например - "(4)" - указавает, что масив состоит из 4-х элементов;
// 2) Далее отображается квадратные скобки внутри которых визуализируется перечень составляющих элементов массива, разделенных между собой с помощью символа ",", например - "['Mango', 'Kiwi', 'Poly', 'Ajax']" - отображает массив из 4-х строчных элементов внутри;
// 3) В начале строки с отображенным в консоли массивом есть стрелочка, нажав на которую можно "развернуть" массив в "вертикально" отображаемый вид (смотри пример в консоли), и внутри, внизу соответствующего перечня 2-а дополнительных пункта с характеристиками массива: "length" - числоввой характеристикой его "длины" (количества элементов в нем) и "[[Prototype]]" - дополнительно разварачиваемого пункта с перечнем всех методов, которые можно применить по отношению к массиву.


// Для автоматического вывода целочисленного значения "длины" массива, можно использовать метод "length"
console.log('Целочисленная "длина" массива "friends" =', friends.length);


// Более удобный способ вывода "логирования" массива в консоль, основан на использовании команды - "console.table([массив])". Которая активирует отображение массива в виде таблицы, в которой отображаются минимум две колонки "(index)" - индекс элемента массива, и "Value" - значение или содержание элемента массива. Если у элементов массива заданы-активированы дополнительные характиристики, то колонок в таблице будет больше, в соответствии с количеством заданных характеристик элементов масива.
console.log('Вывод массива в "лог", с помощью команды "console.table([массив])":');
console.table(friends);


// Индекс элемента массива - это натуральное число, а индекс 1-го элемента в массиве всегда - "0", второго, соответственно - "1", третего - "2" и т.д.
// Для определения индекса последнего элемента массива, так же как и для определения индекса последнего символа в строке (строка - это тоже массив, элементами которого являются символы), можно использовать конструкцию на основе команды - "length - 1".
console.log('Определяем индекс последнего элемента массива "friends":', friends.length - 1);


// Важной особенностью массива является то, что он представляет собой сложный тип данных, который называется - "объектом". В следствии чего, возникает возможность производить любые изменения с данными находящимися внутри массива - "без необходимости его переопределять (перезаписывать и/или переназначать) как переменную любого другого типа данных". При работе с масивом, достаточно один раз его "объявить" в какой-то НЕИЗМЕНЯЕМОЙ (const) переменной, и потом обращаться (добавлять, удалять, копировать и т.д.) к находящимся внутри него данным. По сути, массив - это своеобарзный набор "ячеек" памяти, внутри которых находятся данные, с которыми и производится взаимодействие не затрагивая "внешнюю конструкцию" самого массива.
// Для обращения к элементу, который находится внутри массива необходимо использовать следующую конструкцию - "имя переменной-массива[индекс элемента]".
console.log('Обращаемся к элементу массива "freinds" - с индексом "0" =>', friends[0]);
console.log('Обращаемся к элементу массива "freinds" - с индексом "2" =>', friends[2]);

// Еще один способ обращения к элементу массива, основан на использовании полной записи его литерала и индекса нужного єлемента в двух расположенных друг за другом квадратных скобках - "[22, 33, 44][2]"
console.log('Обращаемся к элементу массива "[22, 33, 44][2]" через литерал =>', [22, 33, 44][2]);

// Если при обращении к элементу массива использовать индекс "НЕ существующего" элемента массива - команда вернет "служебную запись - тип данных" -> "undefind"
console.log('Обращаемся к элементу массива, используя НЕ существующий индекс "friends[5]" =>', friends[5]);


// Переопределение или перезапись значений элементов массива выполняется с помощью использования индекса соответствующего элемента массива, значение которого нужно перезаписать.
// Например, у нас есть массив "collegs -> ['Вася', 'Иштван', 'Моня']", и имя 'Вася' нужно заменить на 'Изя':
const collegs = ['Вася', 'Иштван', 'Моня']; // Объявляем переменную - массив
console.log('Массив "collegs" до изменения:', collegs);
collegs[0] = 'Изя'; // Переопределяем значение ячейки массива под индексом "0"
console.log('Массив "collegs" после 1-го изменения:', collegs);
// Если нужно выполнить еще одну или бесконечное количество подобных переопределений - изменений, они выполняются подобным же образом. Например, в уже измененном один раз массиве "collegs -> ['Изя', 'Иштван', 'Моня']", и имя 'Иштван' нужно заменить на 'Абрам':
collegs[1] = 'Абрам'; // Переопределяем значение ячейки массива под индексом "1"
console.log('Массив "collegs" после 2-го изменения:', collegs);

console.groupEnd(); //! Log group end
console.log('-1----------------------------------------------');


/*
 * Передача по ссылке и по значению:
 * - примитивы и сложные типы;
 * - ссылочное равенство (referential equality).
 */
console.groupCollapsed('Передача по ссылке и по значению'); //! Log group name

// Передача данных по значению основана на записи каждого значения в отдельно взятую ячейку памяти. Например, у нас есть некая переменная "а = 10" и некая переменная "b = a". При передачи данных переменной "b" по значению - для записи данных этой переменной (b) - была выделенна отдельная ячейка памяти, в которую записалось значение "10", соответствующее данным введенным в переменную "b" при ее объявлении. После чего, даже если значение переменной "а" изменится на любое другое, переменная "b" - всеравно будет хранить в себе уже записанное в отдельную ячейку памяти значение "10".

let a = 10; // Объявляем переменную "а" и задаем ей значение "10"
let b = a; // Объявляем переменную "b" и задаем ей значение "= переменной а"
console.log('Начальное значение переменной "а":', a);
console.log('Начальное значение переменной "b":', b);

a = 33; // Изменяем данные в переменной "а"
console.log('Значение переменной "а", после его изменения:', a);
console.log('Значение переменной "b", после изменения переменной "а":', b);


// Передача данных по ссылке работает иначе чем передача данных по значению. Дело в том, что для сложных типов данных, таких как массивы, объекты и функции - любые переменные являются только своеобразными ссылками на место в памяти (на ячейку в памяти), где хранится тот или иной сложный тип данных. Всвязи с чем, на один и тот-же сложный объект, может указывать несколько или целая группа переменных, и при этом, изменения в данных самого такого массива, могут быть осуществленны через любую из переменных связаных сним, а введенные таким образом изменения через одну переменную - отразятся на значениях всех остальных переменных связаных с соответствующим массивом или другим сложным типом данных.
// Например,  у нас есть некая переменная "x", которой мы задаем значение в виде масива -> "[1, 2, 3]". После чего, объявляем переменную "y" и задаем ей значение "= х". Данной опирацией мы создали две "ссылки" на отдельно хранящийся от переменных массив "[1, 2, 3]", 1-ю ссылку в виде переменной "x", и вторую - "y". Теперь, при изменении значений в данных соответствующего массива через переменную "x", эти же изменения отразятся и на значении переменной "y".

const x = [1, 2, 3]; // Объявляем переменную "x" и задаем ей значение в виде массива
const y = x; // Объявляем переменную "y" и задаем ей значение "= переменной x", т.е. - связываем переменную "y" с тем же самым массивом, с которым уже связана переменная "x"

console.log('Начальное значение переменной "x" =>', x);
console.log('Начальное значение переменной "y" =>', y);

x[1] = 500; // Изменяем данные в одном элементе соответствующего масива, через переменную "x" - используя индекс соответствующего элемента массива

console.log('Значение переменной "x", после изменения =>', x);
console.log('Значение переменной "y", после изменения =>', y);
console.log('Сравнение переменных "x === y" =>', x === y);
// Как можно увидить по значениям в "логе" обе указанные переменные отображают одинаковый массив, и при их сравнении - отображается их равенство. Хотя на самом деле, в обоих переменных находится всего-лишь ссылка на один и тот-же массив.


// Важной особенностью любого массива является то, что каждый массив записывается в отдельную ячейку памяти. Именно поэтому два абсолютно одинаковых массива - всегда будут НЕ равны друг другу.
console.log('Сравнение двух массивов "[1, 2, 3] === [1, 2, 3]" =>', [1, 2, 3] === [1, 2, 3]);

console.groupEnd(); //! Log group end
console.log('-2----------------------------------------------');


/*
 * Перебор (итерация) массива: 
 * - for - если нужен индекс или нужно изменить элемент массива;
 * - for...of - если индекс не нужен и в массиве ничего менять не нужно
 */
console.groupCollapsed('Перебор (итерация) массива'); //! Log group name

// При необходимости выполнить перебор состовляющих элементов массива - лучше всего использовать цыклы, в частности "for" или "for...of". Такой подход позволит автоматизировать операцию перебора и при необходимости - подстроить его под работу с массивом любой длины.

// Например, у нас есть массив "girlfriends" в котором содержатся имена 4-х подруг. Для вывода этих имен (данных из массива) можно использовать отдельную операцию вывода каждого элемента массива и уже потом обрабатывать его.
const girlfriends = ['Инесса', 'Ягетта', 'Белла', 'Майя']; // Объявляем переменную с массивом "girlfriends"
console.log('Массив "girlfriends":'); // Предупреждаем о выводе массива
console.table(girlfriends); // Выводим в "лог" массив "girlfriends" в табличном виде

console.log(`Отдельно выводим элемент массива в консоль => "${girlfriends[0]}"`); // Вывод отдельного элемента массива
console.log(`Отдельно выводим элемент массива в консоль => "${girlfriends[1]}"`); // Вывод отдельного элемента массива
console.log(`Отдельно выводим элемент массива в консоль => "${girlfriends[2]}"`); // Вывод отдельного элемента массива
console.log(`Отдельно выводим элемент массива в консоль => "${girlfriends[3]}"`); // Вывод отдельного элемента массива

// А можно определить последний индекс (автоматически выяснить сколько в массиве элементов - узнав индекс последнего элемента в массиве), и автоматически с помощью цыкла - вывести все данные в консоль
const lastIndex = girlfriends.length - 1; // Определяем регистровый номер последнего элемента в массиве

for (let i = 0; i <= lastIndex; i += 1) {
    console.log(`Автоматически выводим "${1 + i}-й" элемент массива c "${i}" - регистровым номером в консоль => "${girlfriends[i]}"`);
}

// Особенностью данного подхода - автоматической обработки всех элементов массива с помощью цыкла, является то, что помимо вывода, так же автоматически с помощью цыкла "for", можно выполнять и другие операции с данными находящимися внутри него. Например, автоматически добавить в каждый элемент массива какие-нибуди данные -> "-;)".
// Отличительными чертами использования цыкла "for" является то, что он позволяет по индексу обращаться к каждому отдельному элементу массива и при необходимости, так-же по индексу - задавать изменения соответствующего элемента. При этом, данный цикл является "настраиваемым" и позволяет задать жесткие правила функционирования (от - до, количество итераций цикла, переменную идентификатор, шаг изменения каждой итерации цыкла).

const neighbours = ['Авдей', 'Авксентий', 'Агапит', 'Агафон']; // Объявляем переменную с массивом "neighbours"
console.log('Исходный вид массива "neighbours":'); // Предупреждаем о выводе массива
console.table(neighbours); // Выводим в "лог" массив "neighbours" в табличном виде
for (let i = 0; i <= neighbours.length - 1; i += 1) {
    neighbours[i] += '-;)'; // Задаем параметры изменений элементов массива
    console.log(`Автоматически изменяем "${1 + i}-й" элемент массива "neighbours" c "${i}" - регистровым номером, и выводим в консоль => "${neighbours[i]}"`);
}
console.log('Измененный вид массива "neighbours":'); // Предупреждаем о выводе измененного массива
console.table(neighbours); // Выводим в "лог" измененный массив "neighbours" в табличном виде


// Еще один цыкл, который помогает выполнить операцию автоматического перебора всех элементов массива - "for...of". Этот цикл предназначен для перебора итерируемых объектов (например, строк, цыклов и т.д.). Отлечительной чертой данного цыкла является то, что его удобно использовать когда: 1) не нужно использовать индекс элементов массива (т.е., если для решения задачи не обязательно использовать индексы элементов массива); 2) не нужно изменять или редактировать элементы обрабатываемого массива.
// Цикл "for...of" по своей синтаксической структуре является менее "декларативным" (в нем меньше используется описательных - декларативных правил: "с чего начинать", "где заканчиваться" и т.д.), чем цыкл "for". В его основу входят два элемента: 1) сам массив который подлежит обработке; 2) служебная переменная в которую записывается каждый последующий элемент обрабатываемого элемента массива.
// Синтаксическая запись цикла "for...of" -> "for (conet [служебная переменная] of [массив])".

const familiars = ['Вадим', 'Константин', 'Спиридон', 'Никифор']; // Объявляем переменную с массивом "familiars"
console.log('Исходный вид массива "familiars":'); // Предупреждаем о выводе массива
console.table(familiars); // Выводим в "лог" массив "familiars" в табличном виде

for (let familiar of familiars) {
    console.log(`Автоматически выводим элемент массива "familiars" => ${familiar}`);
}

// Хорошим тоном, при использовании цыкла "for...of", считается использовать в качестве имени переменной массива - существительное во множественном числе (например, "familiars" - соседи), а для имени задаваемой служебной переменной - существительное в единственном числе (например, "familiar" - сосед). Такой подход НЕ обязателен, но он позволяет по смыслу имен переменных указать где в коде используется массив, а где - его элемент.
// Важно помнить, что цыкл "for...of" - НЕ позволяет изменять элементы массива! А в служебной переменной этого цикла - "лежит" отдельная копия элемента массива (буквально - копия строки 'Вадим', которая соответствует первому элементу массива, копия строки 'Константин' и т.д., при каждой итерации цыкла), а не ссылка на ячейку с данными этого элемента внутри массива. Если нужно получить доступ к ячейке с данными элемента массива - нужно использовать цыкл "for"!!!

console.groupEnd(); //! Log group end
console.log('-3----------------------------------------------');